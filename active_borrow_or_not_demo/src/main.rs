use std::cell::RefCell;
fn main() {
    // 根据所有权规则，在同一个作用域下，不能同时有活跃的可变借用和不可变借用
    // 那么如何定义借用是否活跃呢？
    // 它分为两种情况: 编译器和运行期

    // 1. 编译期,程序正确执行
    let mut a = 5;
    let b = &mut a;
    *b += 1;   // b 结束这次执行后就作为不活跃的可变借用
    let c = &a;  // a 是不可变借用
    println!("{}", c);  // 二者不冲突，所以这段代码正确执行

    // 2. 运行期，程序在运行时 panic
    let data = RefCell::new(1);

    // 获得 RefCell 内部数据的可变借用
    // 获得数据 data 的可变借用，其作用域直到 main 函数结束
    let mut v = data.borrow_mut();
    *v += 1;

    // 获取数据的不可变借用，其作用域直到 main 函数结束，
    // 在同一作用域 (main) 下存在不可变借用和可变借用，这段代码会在运行时 panic
    println!("data: {:?}", data.borrow());
}

// 结论：
// 1. 编译期判定借用是否活跃时，编译器会尽可能缩小变量的生命周期范围；
// 2. 运行期涉及到函数调用，无法缩小声明变量的生命周期，只能在函数调用结束时才能结束.
// 平时的编程过程中，要注意这一点。
